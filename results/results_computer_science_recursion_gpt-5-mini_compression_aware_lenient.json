{
  "concept": "recursion",
  "domain": "computer_science",
  "model": "gpt-5-mini",
  "prompt_strategy": "compression_aware",
  "evaluation_mode": "lenient",
  "performance": [
    {
      "compression_level": 0,
      "context_length": 2,
      "response_length": 2,
      "score": 1.0,
      "verdict": "excellent",
      "hallucinated": [],
      "response": "self-calling function",
      "detailed_eval": {
        "final_score": 1.0,
        "components": {
          "strict": {
            "score": 1.0,
            "found": [
              "self",
              "calling"
            ],
            "missing": [],
            "hallucinated": [],
            "hallucination_penalty": 0.0
          },
          "length": {
            "score": 0.5,
            "response_words": 2,
            "expected_range": [
              10.0,
              30.0
            ]
          }
        },
        "weights": {
          "keyword": 1.0,
          "hallucination": 0.0,
          "length": 0.0
        },
        "verdict": "excellent",
        "response_length": 2,
        "compression_level": 0
      }
    },
    {
      "compression_level": 1,
      "context_length": 6,
      "response_length": 11,
      "score": 1.0,
      "verdict": "excellent",
      "hallucinated": [],
      "response": "They are that the function calls itself and a base case.",
      "detailed_eval": {
        "final_score": 1.0,
        "components": {
          "strict": {
            "score": 1.0,
            "found": [
              "calls itself",
              "base case"
            ],
            "missing": [],
            "hallucinated": [],
            "hallucination_penalty": 0.0
          },
          "length": {
            "score": 1.0,
            "response_words": 11,
            "expected_range": [
              20.0,
              60.0
            ]
          }
        },
        "weights": {
          "keyword": 1.0,
          "hallucination": 0.0,
          "length": 0.0
        },
        "verdict": "excellent",
        "response_length": 11,
        "compression_level": 1
      }
    },
    {
      "compression_level": 2,
      "context_length": 14,
      "response_length": 224,
      "score": 1.0,
      "verdict": "excellent",
      "hallucinated": [
        "additional",
        "after",
        "answered",
        "breaks",
        "built"
      ],
      "response": "A recursive solution has three essential parts and a few important requirements:\n\n1. Base case(s)\n   - The simplest instance(s) of the problem that can be answered directly without further recursion.\n   - Must be reachable and correct (e.g., empty list, n = 0 or n = 1).\n   - Stops recursion and prevents infinite calls.\n\n2. Recursive case(s)\n   - A rule that breaks the current problem into one or more smaller subproblems.\n   - Calls the same function on those smaller inputs.\n   - Must make measurable progress toward a base case (reduce size/complexity).\n\n3. Combination (reconstruction)\n   - After recursive calls return, combine their results to form the answer for the current input.\n   - This is how the full solution is built from subsolutions.\n\nAdditional points to ensure a good recursive solution:\n- Termination: Every recursive path must eventually reach a base case.\n- Correctness: Often proven by induction\u2014if subcalls are correct and combination is correct, the whole is correct.\n- Efficiency: Watch for overlapping subproblems; use memoization or convert to dynamic programming if needed.\n- Resource use: Recursion uses call stack; deep recursion may cause stack overflow unless tail recursion is optimized.\n\nTemplate (pseudocode):\nfunction solve(input):\n  if is_base_case(input):\n    return base_value\n  else:\n    smaller = make_smaller(input)\n    result_sub = solve(smaller)  // possibly multiple recursive calls\n    return combine(result_sub, input)\n\nThis structure\u2014base case, recursive case (reduction), and combination\u2014defines a proper recursive solution.",
      "detailed_eval": {
        "final_score": 1.0,
        "components": {
          "strict": {
            "score": 1.0,
            "found": [
              "subproblems",
              "base case",
              "recursive case",
              "smaller"
            ],
            "missing": [],
            "hallucinated": [
              "additional",
              "after",
              "answered",
              "breaks",
              "built"
            ],
            "hallucination_penalty": 0.0
          },
          "length": {
            "score": 0.7527777777777778,
            "response_words": 224,
            "expected_range": [
              30.0,
              90.0
            ]
          }
        },
        "weights": {
          "keyword": 1.0,
          "hallucination": 0.0,
          "length": 0.0
        },
        "verdict": "excellent",
        "response_length": 224,
        "compression_level": 2
      }
    },
    {
      "compression_level": 3,
      "context_length": 33,
      "response_length": 276,
      "score": 0.6,
      "verdict": "fair",
      "hallucinated": [
        "activation",
        "additional",
        "address",
        "after",
        "allocated"
      ],
      "response": "Each time a function calls itself, the runtime creates a new stack frame (also called an activation record) and pushes it on the call stack. That frame typically holds the function\u2019s parameters for that call, local variables, the return address (where execution should continue after the call returns), and saved CPU registers. Because recursive calls are just ordinary function calls, repeated self-calls push additional frames one after another until a base case is reached.\n\nWhen a base case is encountered the function returns without making more recursive calls. Returning causes the top stack frame to be popped, control and any return value go back to the caller (the previous frame), and execution resumes there. This \u201cpush while recursing, pop while unwinding\u201d behavior means memory use grows with recursion depth: the maximum number of simultaneously live frames equals the deepest chain of nested calls. That makes the auxiliary space cost of recursion proportional to the recursion depth (O(depth)).\n\nIf recursion goes too deep the call stack can exceed its allocated size and the program will crash or throw a stack overflow error. Some language implementations mitigate this with a recursion depth limit (e.g., Python) or with tail-call optimization: if a call is in tail position and the compiler/interpreter supports it, the current frame can be reused for the next call, keeping memory usage constant instead of growing.\n\nPractical consequences:\n- Always make sure there is a correct base case so frames will eventually be popped.\n- Be mindful of recursion depth for large inputs; convert to an iterative approach if necessary.\n- When available, tail recursion or compiler optimizations can eliminate extra frame growth for tail-call patterns.",
      "detailed_eval": {
        "final_score": 0.6,
        "components": {
          "strict": {
            "score": 0.6,
            "found": [
              "base case",
              "stack",
              "parameters"
            ],
            "missing": [
              "call themselves",
              "recursive case"
            ],
            "hallucinated": [
              "activation",
              "additional",
              "address",
              "after",
              "allocated"
            ],
            "hallucination_penalty": 0.0
          },
          "length": {
            "score": 0.9,
            "response_words": 276,
            "expected_range": [
              40.0,
              120.0
            ]
          }
        },
        "weights": {
          "keyword": 1.0,
          "hallucination": 0.0,
          "length": 0.0
        },
        "verdict": "fair",
        "response_length": 276,
        "compression_level": 3
      }
    },
    {
      "compression_level": 4,
      "context_length": 110,
      "response_length": 462,
      "score": 1.0,
      "verdict": "excellent",
      "hallucinated": [
        "action",
        "address",
        "algorithm",
        "algorithms",
        "alternatives"
      ],
      "response": "Recursion is a programming technique where a function solves a problem by calling itself on smaller instances of the same problem until it reaches a simple, directly solvable case. It is especially natural for problems that are self-similar (for example, trees, recursive data structures, divide-and-conquer algorithms).\n\nCore components\n- Base case(s): One or more simplest inputs for which the answer is known without further recursion. Base cases are essential to stop the recursion and prevent infinite calls (and eventual stack overflow).\n- Recursive case(s): Rules that reduce a larger instance of the problem to one or more smaller instances, then combine those results to produce the final answer.\n\nHow it works at runtime\n- Each recursive call creates a new stack frame containing local variables and return address. The call stack keeps track of suspended function instances so that once a deeper call returns, its caller can resume and combine results. This is why deep recursion can exhaust available stack memory.\n\nSimple examples\n- Factorial:\n  function factorial(n):\n    if n == 0: return 1   // base case\n    else: return n * factorial(n-1)   // recursive case\n- Tree traversal:\n  function traverse(node):\n    if node is null: return\n    process(node)\n    for each child in node.children:\n      traverse(child)\n\nAdvantages\n- Elegant and concise expression of solutions for self-similar problems (trees, graphs, combinatorics, fractals).\n- Natural fit for divide-and-conquer algorithms (merge sort, quicksort), backtracking (solving puzzles), and many mathematical definitions.\n\nDisadvantages and risks\n- Function call overhead can make recursive solutions slower and use more memory than iterative versions.\n- Risk of stack overflow for deep recursion (limited call stack depth).\n- Some recursive solutions repeat work and have exponential time without optimization (e.g., naive Fibonacci).\n\nOptimizations and alternatives\n- Tail recursion: when the recursive call is the last action of the function, a compiler or interpreter can optimize it into an iterative loop, eliminating extra stack frames. Not all languages implement this optimization.\n- Memoization / dynamic programming: store results of subproblems to avoid repeated computation and improve time complexity.\n- Convert to iteration when necessary for performance or to avoid stack limits.\n\nCorrectness\n- Recursive algorithms are commonly proven correct by structural induction or mathematical induction: show base cases are correct, then show that if recursive calls work for smaller instances, the algorithm works for the current instance.\n\nDesign tips\n- Always identify clear base case(s) first.\n- Ensure each recursive step makes measurable progress toward a base case.\n- Consider the cost (time/space) and whether memoization or an iterative approach is better for production use.\n- Trace small examples by hand when debugging to confirm flow and state.\n\nIn short, recursion is a powerful conceptual and practical tool for many problems, but it must be used carefully with attention to base cases, resource use, and possible optimizations.",
      "detailed_eval": {
        "final_score": 1.0,
        "components": {
          "strict": {
            "score": 1.0,
            "found": [
              "base case",
              "recursive case",
              "call stack",
              "smaller instances",
              "self-similar",
              "induction"
            ],
            "missing": [],
            "hallucinated": [
              "action",
              "address",
              "algorithm",
              "algorithms",
              "alternatives"
            ],
            "hallucination_penalty": 0.0
          },
          "length": {
            "score": 1.0,
            "response_words": 462,
            "expected_range": [
              50.0,
              150.0
            ]
          }
        },
        "weights": {
          "keyword": 1.0,
          "hallucination": 0.0,
          "length": 0.0
        },
        "verdict": "excellent",
        "response_length": 462,
        "compression_level": 4
      }
    }
  ],
  "failed_levels": [],
  "analysis": {
    "CSI": 5.386946806201267e-18,
    "CSI_stderr": 0.2543522577270752,
    "R_squared": 1.4951780941689008e-34,
    "C_h": 0.01818181818181818,
    "mean_score": 0.9199999999999999,
    "score_variance": 0.16,
    "min_score": 0.6,
    "max_score": 1.0,
    "decay_direction": "decay",
    "n_compression_levels": 5,
    "warnings": [
      "WARNING: Low R\u00b2 (0.000). Non-linear decay pattern. Consider additional analysis."
    ]
  }
}